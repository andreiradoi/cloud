// Code generated by goagen v1.2.0, DO NOT EDIT.
//
// API "fieldkit": input_token Resource Client
//
// Command:
// $ main

package client

import (
	"context"
	"fmt"
	"net/http"
	"net/url"
	"strconv"
)

// AddInputTokenPath computes a request path to the add action of input_token.
func AddInputTokenPath(expeditionID int) string {
	param0 := strconv.Itoa(expeditionID)

	return fmt.Sprintf("/expeditions/%s/input-tokens", param0)
}

// Add an input token
func (c *Client) AddInputToken(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewAddInputTokenRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewAddInputTokenRequest create the request corresponding to the add action endpoint of the input_token resource.
func (c *Client) NewAddInputTokenRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		c.JWTSigner.Sign(req)
	}
	return req, nil
}

// DeleteInputTokenPath computes a request path to the delete action of input_token.
func DeleteInputTokenPath(inputTokenID int) string {
	param0 := strconv.Itoa(inputTokenID)

	return fmt.Sprintf("/input-tokens/%s", param0)
}

// Delete an input token
func (c *Client) DeleteInputToken(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewDeleteInputTokenRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewDeleteInputTokenRequest create the request corresponding to the delete action endpoint of the input_token resource.
func (c *Client) NewDeleteInputTokenRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("DELETE", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		c.JWTSigner.Sign(req)
	}
	return req, nil
}

// ListInputTokenPath computes a request path to the list action of input_token.
func ListInputTokenPath(project string, expedition string) string {
	param0 := project
	param1 := expedition

	return fmt.Sprintf("/projects/@/%s/expeditions/@/%s/input-tokens", param0, param1)
}

// List an expedition's input tokens
func (c *Client) ListInputToken(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewListInputTokenRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewListInputTokenRequest create the request corresponding to the list action endpoint of the input_token resource.
func (c *Client) NewListInputTokenRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		c.JWTSigner.Sign(req)
	}
	return req, nil
}

// ListIDInputTokenPath computes a request path to the list id action of input_token.
func ListIDInputTokenPath(expeditionID int) string {
	param0 := strconv.Itoa(expeditionID)

	return fmt.Sprintf("/expeditions/%s/input-tokens", param0)
}

// Update an expedition's input tokens
func (c *Client) ListIDInputToken(ctx context.Context, path string) (*http.Response, error) {
	req, err := c.NewListIDInputTokenRequest(ctx, path)
	if err != nil {
		return nil, err
	}
	return c.Client.Do(ctx, req)
}

// NewListIDInputTokenRequest create the request corresponding to the list id action endpoint of the input_token resource.
func (c *Client) NewListIDInputTokenRequest(ctx context.Context, path string) (*http.Request, error) {
	scheme := c.Scheme
	if scheme == "" {
		scheme = "https"
	}
	u := url.URL{Host: c.Host, Scheme: scheme, Path: path}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, err
	}
	if c.JWTSigner != nil {
		c.JWTSigner.Sign(req)
	}
	return req, nil
}
